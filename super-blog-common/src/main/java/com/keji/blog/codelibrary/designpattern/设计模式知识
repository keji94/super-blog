一、设计原则
    1.把会变化的部分取出并封装起来，以便以后可以轻易地改变或扩充此部分，而不影响不需要变化的其他部分。
    2.针对接口编程，而不是针对实现编程。
        注：针对接口编程的真正意思是‘针对超类型(supertype)编程’。针对接口编程，关键就在多态。利用多态，程序可以针对
        超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。
            多态：父类引用指向子类对象。
    3.多用组合，少用继承。
    4.为了交互对象之间的松耦合而努力。
    5.类应该对扩展开放，对修改关闭。


二、各模式概念
    1.策略模式：
        策略模式定义了算法族，分别封装起来，让他们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。
    2.观察者模式:
         定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会受到通知并自动更新。
         主题(subject)+观察者(observer)=观察者模式

         观察者模式的两种形态：
            a.主题主动将信息推送给所有观察者。
            b.观察者主动索取数据
         Java内置了观察者模式，支持这两种模式。
         JavaBeans和Swing使用的观察者模式

         要点:
            * 观察者模式定义了对象之间的一对多关系
            * 主题（也就是可被观察者）用一个共同的接口来更新观察者
            * 观察者和可被观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
            * 使用此模式时，你可从被观察者出推（pull）或拉（pull）数据。不过，推的方式被认为更合理。
            * 有多个观察者时，不可以依赖特定的通知次序。
            * Java有多种观察者模式的实现，包括通用的java.util.Observable
            * 要注意java.util.Observable实现上带来的一些问题。
            * 如果有必要的，自己实现Observable
            * Swing大量使用观察者模式，许多GUI框架也是如此。
            * 此模式也被应用在许多地方，例如：JavaBeans，RMI
            * 观察者模式代表人物--MVC

    3.装饰者模式
        定义:动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。

        例子：
            Java中的I/O
            IO中，FileInputStream是一个被装饰的具体组件。BufferedInputStream是一个具体的装饰者，它加入两种行为：利用缓冲输入
            来改进功能；用一个readLine()方法来增强接口。而LineNubmerInputStream又对BufferedInputStream进行了封装。
            BufferedInputStream和LineNubmerInputStream都扩展自FilterInputStream，而FilterInputStream是一个抽象的装饰类。

        缺点：
            利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，会给使用此API的程序员造成看困扰
        要点：
            * 继承属于拓展形式之一，但不见得是达到弹性设计的最佳方案。
            * 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
            * 组合和委托可用于运动时动态地加上新的行为。
            * 除了继承，装饰者模式也可以让我们扩展行为。
            * 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
            * 装饰者类反映出被装饰的组件的类型。

